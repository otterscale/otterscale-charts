apiVersion: v1
kind: ConfigMap
metadata:
  name: modelartifact-script
  labels: 
    {{- if .Values.pvc.labels }}
    {{- include "common.tplvalues.render" ( dict "value" .Values.pvc.labels "context" .) | nindent 4 }}
    {{- end }}
    otterscale.com/modelartifact: {{ include "ma.model.label" . }} 
data:
  download_with_eta.py: |
    # download_with_eta.py
    import argparse, os, time, threading, sys, math
    from huggingface_hub import HfApi, snapshot_download

    def scan_bytes(path: str) -> int:
        total = 0
        for root, _, files in os.walk(path):
            for f in files:
                try:
                    total += os.path.getsize(os.path.join(root, f))
                except FileNotFoundError:
                    pass  # file may be moving
        return total

    def main():
        p = argparse.ArgumentParser()
        p.add_argument("--repo", required=True)
        p.add_argument("--rev", default="main")
        p.add_argument("--local-dir", default="/model")
        p.add_argument("--cache-dir", default="/cache/hf")
        p.add_argument("--interval", type=float, default=3.0)
        p.add_argument("--include", nargs="*", default=None)  # allow_patterns
        p.add_argument("--exclude", nargs="*", default=None)  # ignore_patterns
        p.add_argument("--token", default=os.getenv("HF_TOKEN"))
        args = p.parse_args()

        os.makedirs(args.cache_dir, exist_ok=True)
        os.makedirs(args.local_dir, exist_ok=True)

        # Pre-compute total bytes from metadata (gives per-file sizes when files_metadata=True)
        api = HfApi()
        info = api.model_info(args.repo, revision=args.rev, files_metadata=True, token=args.token)
        sizes = [getattr(s, "size", None) for s in info.siblings]
        sizes = [s for s in sizes if isinstance(s, int)]
        total = sum(sizes) if sizes else 0  # if 0, ETA will be "unknown"

        done = {"flag": False, "err": None}
        def _dl():
            try:
                snapshot_download(
                    repo_id=args.repo,
                    revision=args.rev,
                    token=args.token,
                    cache_dir=args.cache_dir,          # monitor this for "network" progress
                    local_dir=args.local_dir,          # final destination
                    local_dir_use_symlinks=False,      # copy files (log whole-op? monitor local_dir)
                    resume_download=True,
                    allow_patterns=args.include,
                    ignore_patterns=args.exclude,
                )
            except Exception as e:
                done["err"] = repr(e)
            finally:
                done["flag"] = True

        t = threading.Thread(target=_dl, daemon=True)
        t.start()

        start = time.time()
        last_bytes = 0
        last_t = start

        while not done["flag"]:
            cur = scan_bytes(args.cache_dir)
            now = time.time()
            dt = max(now - last_t, 1e-6)
            speed = (cur - last_bytes) / dt
            percent = (cur / total * 100.0) if total > 0 else float("nan")
            remaining = (total - cur) if total > 0 else 0
            eta = (remaining / speed) if (speed > 0 and total > 0) else float("inf")

            # Single-line machine-friendly log (easy to grep/parse)
            print(
                f'PROGRESS repo="{args.repo}" '
                f'bytes={cur} total={total} '
                f'percent={(0 if math.isnan(percent) else percent):.2f} '
                f'speed_bps={speed:.2f} '
                f'eta_sec={(-1 if not math.isfinite(eta) else int(eta))}',
                flush=True
            )
            last_bytes, last_t = cur, now
            time.sleep(args.interval)

        # Final summary
        final = scan_bytes(args.cache_dir)
        elapsed = time.time() - start
        print(
            f'COMPLETE repo="{args.repo}" bytes={final} total={total} '
            f'elapsed_sec={elapsed:.2f} path="{args.local_dir}" '
            f'error="{done["err"]}"',
            flush=True
        )
        if done["err"]:
            sys.exit(1)

    if __name__ == "__main__":
        main()
